{"version":3,"sources":["node_modules/mousetrap/mousetrap.js","node_modules/angular2-hotkeys/fesm2022/angular2-hotkeys.mjs"],"sourcesContent":["/*global define:false */\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.5\n * @url craig.is/killing/mice\n */\n(function (window, document, undefined) {\n  // Check if mousetrap is used inside browser, if not, return\n  if (!window) {\n    return;\n  }\n\n  /**\n   * mapping of special keycodes to their corresponding keys\n   *\n   * everything in this dictionary cannot use keypress events\n   * so it has to be here to map to the correct keycodes for\n   * keyup/keydown events\n   *\n   * @type {Object}\n   */\n  var _MAP = {\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    16: 'shift',\n    17: 'ctrl',\n    18: 'alt',\n    20: 'capslock',\n    27: 'esc',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    35: 'end',\n    36: 'home',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down',\n    45: 'ins',\n    46: 'del',\n    91: 'meta',\n    93: 'meta',\n    224: 'meta'\n  };\n\n  /**\n   * mapping for special characters so they can support\n   *\n   * this dictionary is only used incase you want to bind a\n   * keyup or keydown event to one of these keys\n   *\n   * @type {Object}\n   */\n  var _KEYCODE_MAP = {\n    106: '*',\n    107: '+',\n    109: '-',\n    110: '.',\n    111: '/',\n    186: ';',\n    187: '=',\n    188: ',',\n    189: '-',\n    190: '.',\n    191: '/',\n    192: '`',\n    219: '[',\n    220: '\\\\',\n    221: ']',\n    222: '\\''\n  };\n\n  /**\n   * this is a mapping of keys that require shift on a US keypad\n   * back to the non shift equivelents\n   *\n   * this is so you can use keyup events with these keys\n   *\n   * note that this will only work reliably on US keyboards\n   *\n   * @type {Object}\n   */\n  var _SHIFT_MAP = {\n    '~': '`',\n    '!': '1',\n    '@': '2',\n    '#': '3',\n    '$': '4',\n    '%': '5',\n    '^': '6',\n    '&': '7',\n    '*': '8',\n    '(': '9',\n    ')': '0',\n    '_': '-',\n    '+': '=',\n    ':': ';',\n    '\\\"': '\\'',\n    '<': ',',\n    '>': '.',\n    '?': '/',\n    '|': '\\\\'\n  };\n\n  /**\n   * this is a list of special strings you can use to map\n   * to modifier keys when you specify your keyboard shortcuts\n   *\n   * @type {Object}\n   */\n  var _SPECIAL_ALIASES = {\n    'option': 'alt',\n    'command': 'meta',\n    'return': 'enter',\n    'escape': 'esc',\n    'plus': '+',\n    'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n  };\n\n  /**\n   * variable to store the flipped version of _MAP from above\n   * needed to check if we should use keypress or not when no action\n   * is specified\n   *\n   * @type {Object|undefined}\n   */\n  var _REVERSE_MAP;\n\n  /**\n   * loop through the f keys, f1 to f19 and add them to the map\n   * programatically\n   */\n  for (var i = 1; i < 20; ++i) {\n    _MAP[111 + i] = 'f' + i;\n  }\n\n  /**\n   * loop through to map numbers on the numeric keypad\n   */\n  for (i = 0; i <= 9; ++i) {\n    // This needs to use a string cause otherwise since 0 is falsey\n    // mousetrap will never fire for numpad 0 pressed as part of a keydown\n    // event.\n    //\n    // @see https://github.com/ccampbell/mousetrap/pull/258\n    _MAP[i + 96] = i.toString();\n  }\n\n  /**\n   * cross browser add event method\n   *\n   * @param {Element|HTMLDocument} object\n   * @param {string} type\n   * @param {Function} callback\n   * @returns void\n   */\n  function _addEvent(object, type, callback) {\n    if (object.addEventListener) {\n      object.addEventListener(type, callback, false);\n      return;\n    }\n    object.attachEvent('on' + type, callback);\n  }\n\n  /**\n   * takes the event and returns the key character\n   *\n   * @param {Event} e\n   * @return {string}\n   */\n  function _characterFromEvent(e) {\n    // for keypress events we should return the character as is\n    if (e.type == 'keypress') {\n      var character = String.fromCharCode(e.which);\n\n      // if the shift key is not pressed then it is safe to assume\n      // that we want the character to be lowercase.  this means if\n      // you accidentally have caps lock on then your key bindings\n      // will continue to work\n      //\n      // the only side effect that might not be desired is if you\n      // bind something like 'A' cause you want to trigger an\n      // event when capital A is pressed caps lock will no longer\n      // trigger the event.  shift+a will though.\n      if (!e.shiftKey) {\n        character = character.toLowerCase();\n      }\n      return character;\n    }\n\n    // for non keypress events the special maps are needed\n    if (_MAP[e.which]) {\n      return _MAP[e.which];\n    }\n    if (_KEYCODE_MAP[e.which]) {\n      return _KEYCODE_MAP[e.which];\n    }\n\n    // if it is not in the special map\n\n    // with keydown and keyup events the character seems to always\n    // come in as an uppercase character whether you are pressing shift\n    // or not.  we should make sure it is always lowercase for comparisons\n    return String.fromCharCode(e.which).toLowerCase();\n  }\n\n  /**\n   * checks if two arrays are equal\n   *\n   * @param {Array} modifiers1\n   * @param {Array} modifiers2\n   * @returns {boolean}\n   */\n  function _modifiersMatch(modifiers1, modifiers2) {\n    return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n  }\n\n  /**\n   * takes a key event and figures out what the modifiers are\n   *\n   * @param {Event} e\n   * @returns {Array}\n   */\n  function _eventModifiers(e) {\n    var modifiers = [];\n    if (e.shiftKey) {\n      modifiers.push('shift');\n    }\n    if (e.altKey) {\n      modifiers.push('alt');\n    }\n    if (e.ctrlKey) {\n      modifiers.push('ctrl');\n    }\n    if (e.metaKey) {\n      modifiers.push('meta');\n    }\n    return modifiers;\n  }\n\n  /**\n   * prevents default for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n  function _preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n      return;\n    }\n    e.returnValue = false;\n  }\n\n  /**\n   * stops propogation for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n  function _stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n      return;\n    }\n    e.cancelBubble = true;\n  }\n\n  /**\n   * determines if the keycode specified is a modifier key or not\n   *\n   * @param {string} key\n   * @returns {boolean}\n   */\n  function _isModifier(key) {\n    return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n  }\n\n  /**\n   * reverses the map lookup so that we can look for specific keys\n   * to see what can and can't use keypress\n   *\n   * @return {Object}\n   */\n  function _getReverseMap() {\n    if (!_REVERSE_MAP) {\n      _REVERSE_MAP = {};\n      for (var key in _MAP) {\n        // pull out the numeric keypad from here cause keypress should\n        // be able to detect the keys from the character\n        if (key > 95 && key < 112) {\n          continue;\n        }\n        if (_MAP.hasOwnProperty(key)) {\n          _REVERSE_MAP[_MAP[key]] = key;\n        }\n      }\n    }\n    return _REVERSE_MAP;\n  }\n\n  /**\n   * picks the best action based on the key combination\n   *\n   * @param {string} key - character for key\n   * @param {Array} modifiers\n   * @param {string=} action passed in\n   */\n  function _pickBestAction(key, modifiers, action) {\n    // if no action was picked in we should try to pick the one\n    // that we think would work best for this key\n    if (!action) {\n      action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n    }\n\n    // modifier keys don't work as expected with keypress,\n    // switch to keydown\n    if (action == 'keypress' && modifiers.length) {\n      action = 'keydown';\n    }\n    return action;\n  }\n\n  /**\n   * Converts from a string key combination to an array\n   *\n   * @param  {string} combination like \"command+shift+l\"\n   * @return {Array}\n   */\n  function _keysFromString(combination) {\n    if (combination === '+') {\n      return ['+'];\n    }\n    combination = combination.replace(/\\+{2}/g, '+plus');\n    return combination.split('+');\n  }\n\n  /**\n   * Gets info for a specific key combination\n   *\n   * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n   * @param  {string=} action\n   * @returns {Object}\n   */\n  function _getKeyInfo(combination, action) {\n    var keys;\n    var key;\n    var i;\n    var modifiers = [];\n\n    // take the keys from this pattern and figure out what the actual\n    // pattern is all about\n    keys = _keysFromString(combination);\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n\n      // normalize key names\n      if (_SPECIAL_ALIASES[key]) {\n        key = _SPECIAL_ALIASES[key];\n      }\n\n      // if this is not a keypress event then we should\n      // be smart about using shift keys\n      // this will only work for US keyboards however\n      if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n        key = _SHIFT_MAP[key];\n        modifiers.push('shift');\n      }\n\n      // if this key is a modifier then add it to the list of modifiers\n      if (_isModifier(key)) {\n        modifiers.push(key);\n      }\n    }\n\n    // depending on what the key combination is\n    // we will try to pick the best event for it\n    action = _pickBestAction(key, modifiers, action);\n    return {\n      key: key,\n      modifiers: modifiers,\n      action: action\n    };\n  }\n  function _belongsTo(element, ancestor) {\n    if (element === null || element === document) {\n      return false;\n    }\n    if (element === ancestor) {\n      return true;\n    }\n    return _belongsTo(element.parentNode, ancestor);\n  }\n  function Mousetrap(targetElement) {\n    var self = this;\n    targetElement = targetElement || document;\n    if (!(self instanceof Mousetrap)) {\n      return new Mousetrap(targetElement);\n    }\n\n    /**\n     * element to attach key events to\n     *\n     * @type {Element}\n     */\n    self.target = targetElement;\n\n    /**\n     * a list of all the callbacks setup via Mousetrap.bind()\n     *\n     * @type {Object}\n     */\n    self._callbacks = {};\n\n    /**\n     * direct map of string combinations to callbacks used for trigger()\n     *\n     * @type {Object}\n     */\n    self._directMap = {};\n\n    /**\n     * keeps track of what level each sequence is at since multiple\n     * sequences can start out with the same sequence\n     *\n     * @type {Object}\n     */\n    var _sequenceLevels = {};\n\n    /**\n     * variable to store the setTimeout call\n     *\n     * @type {null|number}\n     */\n    var _resetTimer;\n\n    /**\n     * temporary state where we will ignore the next keyup\n     *\n     * @type {boolean|string}\n     */\n    var _ignoreNextKeyup = false;\n\n    /**\n     * temporary state where we will ignore the next keypress\n     *\n     * @type {boolean}\n     */\n    var _ignoreNextKeypress = false;\n\n    /**\n     * are we currently inside of a sequence?\n     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n     *\n     * @type {boolean|string}\n     */\n    var _nextExpectedAction = false;\n\n    /**\n     * resets all sequence counters except for the ones passed in\n     *\n     * @param {Object} doNotReset\n     * @returns void\n     */\n    function _resetSequences(doNotReset) {\n      doNotReset = doNotReset || {};\n      var activeSequences = false,\n        key;\n      for (key in _sequenceLevels) {\n        if (doNotReset[key]) {\n          activeSequences = true;\n          continue;\n        }\n        _sequenceLevels[key] = 0;\n      }\n      if (!activeSequences) {\n        _nextExpectedAction = false;\n      }\n    }\n\n    /**\n     * finds all callbacks that match based on the keycode, modifiers,\n     * and action\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event|Object} e\n     * @param {string=} sequenceName - name of the sequence we are looking for\n     * @param {string=} combination\n     * @param {number=} level\n     * @returns {Array}\n     */\n    function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n      var i;\n      var callback;\n      var matches = [];\n      var action = e.type;\n\n      // if there are no events related to this keycode\n      if (!self._callbacks[character]) {\n        return [];\n      }\n\n      // if a modifier key is coming up on its own we should allow it\n      if (action == 'keyup' && _isModifier(character)) {\n        modifiers = [character];\n      }\n\n      // loop through all callbacks for the key that was pressed\n      // and see if any of them match\n      for (i = 0; i < self._callbacks[character].length; ++i) {\n        callback = self._callbacks[character][i];\n\n        // if a sequence name is not specified, but this is a sequence at\n        // the wrong level then move onto the next match\n        if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n          continue;\n        }\n\n        // if the action we are looking for doesn't match the action we got\n        // then we should keep going\n        if (action != callback.action) {\n          continue;\n        }\n\n        // if this is a keypress event and the meta key and control key\n        // are not pressed that means that we need to only look at the\n        // character, otherwise check the modifiers as well\n        //\n        // chrome will not fire a keypress if meta or control is down\n        // safari will fire a keypress if meta or meta+shift is down\n        // firefox will fire a keypress if meta or control is down\n        if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {\n          // when you bind a combination or sequence a second time it\n          // should overwrite the first one.  if a sequenceName or\n          // combination is specified in this call it does just that\n          //\n          // @todo make deleting its own method?\n          var deleteCombo = !sequenceName && callback.combo == combination;\n          var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n          if (deleteCombo || deleteSequence) {\n            self._callbacks[character].splice(i, 1);\n          }\n          matches.push(callback);\n        }\n      }\n      return matches;\n    }\n\n    /**\n     * actually calls the callback function\n     *\n     * if your callback function returns false this will use the jquery\n     * convention - prevent default and stop propogation on the event\n     *\n     * @param {Function} callback\n     * @param {Event} e\n     * @returns void\n     */\n    function _fireCallback(callback, e, combo, sequence) {\n      // if this event should not happen stop here\n      if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n        return;\n      }\n      if (callback(e, combo) === false) {\n        _preventDefault(e);\n        _stopPropagation(e);\n      }\n    }\n\n    /**\n     * handles a character key event\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event} e\n     * @returns void\n     */\n    self._handleKey = function (character, modifiers, e) {\n      var callbacks = _getMatches(character, modifiers, e);\n      var i;\n      var doNotReset = {};\n      var maxLevel = 0;\n      var processedSequenceCallback = false;\n\n      // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n      for (i = 0; i < callbacks.length; ++i) {\n        if (callbacks[i].seq) {\n          maxLevel = Math.max(maxLevel, callbacks[i].level);\n        }\n      }\n\n      // loop through matching callbacks for this key event\n      for (i = 0; i < callbacks.length; ++i) {\n        // fire for all sequence callbacks\n        // this is because if for example you have multiple sequences\n        // bound such as \"g i\" and \"g t\" they both need to fire the\n        // callback for matching g cause otherwise you can only ever\n        // match the first one\n        if (callbacks[i].seq) {\n          // only fire callbacks for the maxLevel to prevent\n          // subsequences from also firing\n          //\n          // for example 'a option b' should not cause 'option b' to fire\n          // even though 'option b' is part of the other sequence\n          //\n          // any sequences that do not match here will be discarded\n          // below by the _resetSequences call\n          if (callbacks[i].level != maxLevel) {\n            continue;\n          }\n          processedSequenceCallback = true;\n\n          // keep a list of which sequences were matches for later\n          doNotReset[callbacks[i].seq] = 1;\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n          continue;\n        }\n\n        // if there were no sequence matches but we are still here\n        // that means this is a regular match so we should fire that\n        if (!processedSequenceCallback) {\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n        }\n      }\n\n      // if the key you pressed matches the type of sequence without\n      // being a modifier (ie \"keyup\" or \"keypress\") then we should\n      // reset all sequences that were not matched by this event\n      //\n      // this is so, for example, if you have the sequence \"h a t\" and you\n      // type \"h e a r t\" it does not match.  in this case the \"e\" will\n      // cause the sequence to reset\n      //\n      // modifier keys are ignored because you can have a sequence\n      // that contains modifiers such as \"enter ctrl+space\" and in most\n      // cases the modifier key will be pressed before the next key\n      //\n      // also if you have a sequence such as \"ctrl+b a\" then pressing the\n      // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n      //\n      // the \"keydown\" is expected when there is a modifier, but the\n      // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n      // after and that causes the sequence to reset\n      //\n      // we ignore keypresses in a sequence that directly follow a keydown\n      // for the same character\n      var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n      if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n        _resetSequences(doNotReset);\n      }\n      _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n    };\n\n    /**\n     * handles a keydown event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _handleKeyEvent(e) {\n      // normalize e.which for key events\n      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n      if (typeof e.which !== 'number') {\n        e.which = e.keyCode;\n      }\n      var character = _characterFromEvent(e);\n\n      // no character found then stop\n      if (!character) {\n        return;\n      }\n\n      // need to use === for the character check because the character can be 0\n      if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n        _ignoreNextKeyup = false;\n        return;\n      }\n      self.handleKey(character, _eventModifiers(e), e);\n    }\n\n    /**\n     * called to set a 1 second timeout on the specified sequence\n     *\n     * this is so after each key press in the sequence you have 1 second\n     * to press the next key before you have to start over\n     *\n     * @returns void\n     */\n    function _resetSequenceTimer() {\n      clearTimeout(_resetTimer);\n      _resetTimer = setTimeout(_resetSequences, 1000);\n    }\n\n    /**\n     * binds a key sequence to an event\n     *\n     * @param {string} combo - combo specified in bind call\n     * @param {Array} keys\n     * @param {Function} callback\n     * @param {string=} action\n     * @returns void\n     */\n    function _bindSequence(combo, keys, callback, action) {\n      // start off by adding a sequence level record for this combination\n      // and setting the level to 0\n      _sequenceLevels[combo] = 0;\n\n      /**\n       * callback to increase the sequence level for this sequence and reset\n       * all other sequences that were active\n       *\n       * @param {string} nextAction\n       * @returns {Function}\n       */\n      function _increaseSequence(nextAction) {\n        return function () {\n          _nextExpectedAction = nextAction;\n          ++_sequenceLevels[combo];\n          _resetSequenceTimer();\n        };\n      }\n\n      /**\n       * wraps the specified callback inside of another function in order\n       * to reset all sequence counters as soon as this sequence is done\n       *\n       * @param {Event} e\n       * @returns void\n       */\n      function _callbackAndReset(e) {\n        _fireCallback(callback, e, combo);\n\n        // we should ignore the next key up if the action is key down\n        // or keypress.  this is so if you finish a sequence and\n        // release the key the final key will not trigger a keyup\n        if (action !== 'keyup') {\n          _ignoreNextKeyup = _characterFromEvent(e);\n        }\n\n        // weird race condition if a sequence ends with the key\n        // another sequence begins with\n        setTimeout(_resetSequences, 10);\n      }\n\n      // loop through keys one at a time and bind the appropriate callback\n      // function.  for any key leading up to the final one it should\n      // increase the sequence. after the final, it should reset all sequences\n      //\n      // if an action is specified in the original bind call then that will\n      // be used throughout.  otherwise we will pass the action that the\n      // next key in the sequence should match.  this allows a sequence\n      // to mix and match keypress and keydown events depending on which\n      // ones are better suited to the key provided\n      for (var i = 0; i < keys.length; ++i) {\n        var isFinal = i + 1 === keys.length;\n        var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n        _bindSingle(keys[i], wrappedCallback, action, combo, i);\n      }\n    }\n\n    /**\n     * binds a single keyboard combination\n     *\n     * @param {string} combination\n     * @param {Function} callback\n     * @param {string=} action\n     * @param {string=} sequenceName - name of sequence if part of sequence\n     * @param {number=} level - what part of the sequence the command is\n     * @returns void\n     */\n    function _bindSingle(combination, callback, action, sequenceName, level) {\n      // store a direct mapped reference for use with Mousetrap.trigger\n      self._directMap[combination + ':' + action] = callback;\n\n      // make sure multiple spaces in a row become a single space\n      combination = combination.replace(/\\s+/g, ' ');\n      var sequence = combination.split(' ');\n      var info;\n\n      // if this pattern is a sequence of keys then run through this method\n      // to reprocess each pattern one key at a time\n      if (sequence.length > 1) {\n        _bindSequence(combination, sequence, callback, action);\n        return;\n      }\n      info = _getKeyInfo(combination, action);\n\n      // make sure to initialize array if this is the first time\n      // a callback is added for this key\n      self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n      // remove an existing match if there is one\n      _getMatches(info.key, info.modifiers, {\n        type: info.action\n      }, sequenceName, combination, level);\n\n      // add this call back to the array\n      // if it is a sequence put it at the beginning\n      // if not put it at the end\n      //\n      // this is important because the way these are processed expects\n      // the sequence ones to come first\n      self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n        callback: callback,\n        modifiers: info.modifiers,\n        action: info.action,\n        seq: sequenceName,\n        level: level,\n        combo: combination\n      });\n    }\n\n    /**\n     * binds multiple combinations to the same callback\n     *\n     * @param {Array} combinations\n     * @param {Function} callback\n     * @param {string|undefined} action\n     * @returns void\n     */\n    self._bindMultiple = function (combinations, callback, action) {\n      for (var i = 0; i < combinations.length; ++i) {\n        _bindSingle(combinations[i], callback, action);\n      }\n    };\n\n    // start!\n    _addEvent(targetElement, 'keypress', _handleKeyEvent);\n    _addEvent(targetElement, 'keydown', _handleKeyEvent);\n    _addEvent(targetElement, 'keyup', _handleKeyEvent);\n  }\n\n  /**\n   * binds an event to mousetrap\n   *\n   * can be a single key, a combination of keys separated with +,\n   * an array of keys, or a sequence of keys separated by spaces\n   *\n   * be sure to list the modifier keys first to make sure that the\n   * correct key ends up getting bound (the last key in the pattern)\n   *\n   * @param {string|Array} keys\n   * @param {Function} callback\n   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n   * @returns void\n   */\n  Mousetrap.prototype.bind = function (keys, callback, action) {\n    var self = this;\n    keys = keys instanceof Array ? keys : [keys];\n    self._bindMultiple.call(self, keys, callback, action);\n    return self;\n  };\n\n  /**\n   * unbinds an event to mousetrap\n   *\n   * the unbinding sets the callback function of the specified key combo\n   * to an empty function and deletes the corresponding key in the\n   * _directMap dict.\n   *\n   * TODO: actually remove this from the _callbacks dictionary instead\n   * of binding an empty function\n   *\n   * the keycombo+action has to be exactly the same as\n   * it was defined in the bind method\n   *\n   * @param {string|Array} keys\n   * @param {string} action\n   * @returns void\n   */\n  Mousetrap.prototype.unbind = function (keys, action) {\n    var self = this;\n    return self.bind.call(self, keys, function () {}, action);\n  };\n\n  /**\n   * triggers an event that has already been bound\n   *\n   * @param {string} keys\n   * @param {string=} action\n   * @returns void\n   */\n  Mousetrap.prototype.trigger = function (keys, action) {\n    var self = this;\n    if (self._directMap[keys + ':' + action]) {\n      self._directMap[keys + ':' + action]({}, keys);\n    }\n    return self;\n  };\n\n  /**\n   * resets the library back to its initial state.  this is useful\n   * if you want to clear out the current keyboard shortcuts and bind\n   * new ones - for example if you switch to another page\n   *\n   * @returns void\n   */\n  Mousetrap.prototype.reset = function () {\n    var self = this;\n    self._callbacks = {};\n    self._directMap = {};\n    return self;\n  };\n\n  /**\n   * should we stop this event before firing off callbacks\n   *\n   * @param {Event} e\n   * @param {Element} element\n   * @return {boolean}\n   */\n  Mousetrap.prototype.stopCallback = function (e, element) {\n    var self = this;\n\n    // if the element has the class \"mousetrap\" then no need to stop\n    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n      return false;\n    }\n    if (_belongsTo(element, self.target)) {\n      return false;\n    }\n\n    // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,\n    // not the initial event target in the shadow tree. Note that not all events cross the\n    // shadow boundary.\n    // For shadow trees with `mode: 'open'`, the initial event target is the first element in\n    // the event’s composed path. For shadow trees with `mode: 'closed'`, the initial event\n    // target cannot be obtained.\n    if ('composedPath' in e && typeof e.composedPath === 'function') {\n      // For open shadow trees, update `element` so that the following check works.\n      var initialEventTarget = e.composedPath()[0];\n      if (initialEventTarget !== e.target) {\n        element = initialEventTarget;\n      }\n    }\n\n    // stop for input, select, and textarea\n    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n  };\n\n  /**\n   * exposes _handleKey publicly so it can be overwritten by extensions\n   */\n  Mousetrap.prototype.handleKey = function () {\n    var self = this;\n    return self._handleKey.apply(self, arguments);\n  };\n\n  /**\n   * allow custom key mappings\n   */\n  Mousetrap.addKeycodes = function (object) {\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        _MAP[key] = object[key];\n      }\n    }\n    _REVERSE_MAP = null;\n  };\n\n  /**\n   * Init the global mousetrap functions\n   *\n   * This method is needed to allow the global mousetrap functions to work\n   * now that mousetrap is a constructor function.\n   */\n  Mousetrap.init = function () {\n    var documentMousetrap = Mousetrap(document);\n    for (var method in documentMousetrap) {\n      if (method.charAt(0) !== '_') {\n        Mousetrap[method] = function (method) {\n          return function () {\n            return documentMousetrap[method].apply(documentMousetrap, arguments);\n          };\n        }(method);\n      }\n    }\n  };\n  Mousetrap.init();\n\n  // expose mousetrap to the global object\n  window.Mousetrap = Mousetrap;\n\n  // expose as a common js module\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Mousetrap;\n  }\n\n  // expose mousetrap as an AMD module\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return Mousetrap;\n    });\n  }\n})(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null);","import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, Directive, Input, Component, NgModule } from '@angular/core';\nimport { Subject, BehaviorSubject } from 'rxjs';\nimport * as Mousetrap from 'mousetrap';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nconst _c0 = a0 => ({\n  \"in\": a0\n});\nfunction HotkeysCheatsheetComponent_tr_7_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 8);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const key_r1 = ctx.$implicit;\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(key_r1);\n  }\n}\nfunction HotkeysCheatsheetComponent_tr_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\")(1, \"td\", 5);\n    i0.ɵɵtemplate(2, HotkeysCheatsheetComponent_tr_7_span_2_Template, 2, 1, \"span\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"td\", 7);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const hotkey_r2 = ctx.$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", hotkey_r2.formatted);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(hotkey_r2.description);\n  }\n}\nclass Hotkey {\n  static symbolize(combo) {\n    const map = {\n      command: '\\u2318',\n      shift: '\\u21E7',\n      left: '\\u2190',\n      right: '\\u2192',\n      up: '\\u2191',\n      down: '\\u2193',\n      // tslint:disable-next-line:object-literal-key-quotes\n      'return': '\\u23CE',\n      backspace: '\\u232B' // ⌫\n    };\n    const comboSplit = combo.split('+');\n    for (let i = 0; i < comboSplit.length; i++) {\n      // try to resolve command / ctrl based on OS:\n      if (comboSplit[i] === 'mod') {\n        if (window.navigator && window.navigator.platform.indexOf('Mac') >= 0) {\n          comboSplit[i] = 'command';\n        } else {\n          comboSplit[i] = 'ctrl';\n        }\n      }\n      comboSplit[i] = map[comboSplit[i]] || comboSplit[i];\n    }\n    return comboSplit.join(' + ');\n  }\n  /**\n   * Creates a new Hotkey for Mousetrap binding\n   *\n   * @param combo       mousetrap key binding\n   * @param callback    method to call when key is pressed\n   * @param allowIn     an array of tag names to allow this combo in ('INPUT', 'SELECT', and/or 'TEXTAREA')\n   * @param description description for the help menu\n   * @param action      the type of event to listen for (for mousetrap)\n   * @param persistent  if true, the binding is preserved upon route changes\n   */\n  constructor(combo, callback, allowIn, description, action, persistent) {\n    this.combo = combo;\n    this.callback = callback;\n    this.allowIn = allowIn;\n    this.description = description;\n    this.action = action;\n    this.persistent = persistent;\n    this.combo = Array.isArray(combo) ? combo : [combo];\n    this.allowIn = allowIn || [];\n    this.description = description || '';\n  }\n  get formatted() {\n    if (!this.formattedHotkey) {\n      const sequence = [...this.combo];\n      for (let i = 0; i < sequence.length; i++) {\n        sequence[i] = Hotkey.symbolize(sequence[i]);\n      }\n      this.formattedHotkey = sequence;\n    }\n    return this.formattedHotkey;\n  }\n}\nconst HotkeyOptions = new InjectionToken('HotkeyOptions');\nlet HotkeysService = /*#__PURE__*/(() => {\n  class HotkeysService {\n    constructor(options) {\n      this.options = options;\n      this.hotkeys = [];\n      this.pausedHotkeys = [];\n      this.cheatSheetToggle = new Subject();\n      this.preventIn = ['INPUT', 'SELECT', 'TEXTAREA'];\n      // noinspection JSUnusedGlobalSymbols,JSUnusedLocalSymbols\n      Mousetrap.prototype.stopCallback = (event, element, combo, callback) => {\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n          return false;\n        }\n        return element.contentEditable && element.contentEditable === 'true';\n      };\n      this.mousetrap = new Mousetrap.default();\n      this.initCheatSheet();\n    }\n    initCheatSheet() {\n      if (!this.options.disableCheatSheet) {\n        this.add(new Hotkey(this.options.cheatSheetHotkey || '?', function (_) {\n          this.cheatSheetToggle.next();\n        }.bind(this), [], this.options.cheatSheetDescription || 'Show / hide this help menu'));\n      }\n      if (this.options.cheatSheetCloseEsc) {\n        this.add(new Hotkey('esc', function (_) {\n          this.cheatSheetToggle.next(false);\n        }.bind(this), ['HOTKEYS-CHEATSHEET'], this.options.cheatSheetCloseEscDescription || 'Hide this help menu'));\n      }\n    }\n    add(hotkey, specificEvent) {\n      if (Array.isArray(hotkey)) {\n        const temp = [];\n        for (const key of hotkey) {\n          temp.push(this.add(key, specificEvent));\n        }\n        return temp;\n      }\n      this.remove(hotkey);\n      this.hotkeys.push(hotkey);\n      this.mousetrap.bind(hotkey.combo, (event, combo) => {\n        let shouldExecute = true;\n        // if the callback is executed directly `hotkey.get('w').callback()`\n        // there will be no event, so just execute the callback.\n        if (event) {\n          const target = event.target || event.srcElement; // srcElement is IE only\n          const nodeName = target.nodeName.toUpperCase();\n          // check if the input has a mousetrap class, and skip checking preventIn if so\n          if ((' ' + target.className + ' ').indexOf(' mousetrap ') > -1) {\n            shouldExecute = true;\n          } else if (this.preventIn.indexOf(nodeName) > -1 && hotkey.allowIn.map(allow => allow.toUpperCase()).indexOf(nodeName) === -1) {\n            // don't execute callback if the event was fired from inside an element listed in preventIn but not in allowIn\n            shouldExecute = false;\n          }\n        }\n        if (shouldExecute) {\n          return hotkey.callback.apply(this, [event, combo]);\n        }\n      }, specificEvent);\n      return hotkey;\n    }\n    remove(hotkey, specificEvent) {\n      const temp = [];\n      if (!hotkey) {\n        for (const key of this.hotkeys) {\n          temp.push(this.remove(key, specificEvent));\n        }\n        return temp;\n      }\n      if (Array.isArray(hotkey)) {\n        for (const key of hotkey) {\n          temp.push(this.remove(key));\n        }\n        return temp;\n      }\n      const index = this.findHotkey(hotkey);\n      if (index > -1) {\n        this.hotkeys.splice(index, 1);\n        this.mousetrap.unbind(hotkey.combo, specificEvent);\n        return hotkey;\n      }\n      return null;\n    }\n    get(combo) {\n      if (!combo) {\n        return this.hotkeys;\n      }\n      if (Array.isArray(combo)) {\n        const temp = [];\n        for (const key of combo) {\n          temp.push(this.get(key));\n        }\n        return temp;\n      }\n      for (const hotkey of this.hotkeys) {\n        if (hotkey.combo.indexOf(combo) > -1) {\n          return hotkey;\n        }\n      }\n      return null;\n    }\n    // noinspection JSUnusedGlobalSymbols\n    pause(hotkey) {\n      if (!hotkey) {\n        return this.pause(this.hotkeys);\n      }\n      if (Array.isArray(hotkey)) {\n        const temp = [];\n        for (const key of hotkey.slice()) {\n          temp.push(this.pause(key));\n        }\n        return temp;\n      }\n      this.remove(hotkey);\n      this.pausedHotkeys.push(hotkey);\n      return hotkey;\n    }\n    // noinspection JSUnusedGlobalSymbols\n    unpause(hotkey) {\n      if (!hotkey) {\n        return this.unpause(this.pausedHotkeys);\n      }\n      if (Array.isArray(hotkey)) {\n        const temp = [];\n        for (const key of hotkey.slice()) {\n          temp.push(this.unpause(key));\n        }\n        return temp;\n      }\n      const index = this.pausedHotkeys.indexOf(hotkey);\n      if (index > -1) {\n        this.add(hotkey);\n        return this.pausedHotkeys.splice(index, 1);\n      }\n      return null;\n    }\n    // noinspection JSUnusedGlobalSymbols\n    reset() {\n      this.mousetrap.reset();\n      this.hotkeys = [];\n      this.pausedHotkeys = [];\n      this.initCheatSheet();\n    }\n    findHotkey(hotkey) {\n      return this.hotkeys.indexOf(hotkey);\n    }\n    static {\n      this.ɵfac = function HotkeysService_Factory(t) {\n        return new (t || HotkeysService)(i0.ɵɵinject(HotkeyOptions));\n      };\n    }\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: HotkeysService,\n        factory: HotkeysService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return HotkeysService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HotkeysDirective = /*#__PURE__*/(() => {\n  class HotkeysDirective {\n    constructor(hotkeysService, elementRef) {\n      this.hotkeysService = hotkeysService;\n      this.elementRef = elementRef;\n      this.hotkeysList = [];\n      this.oldHotkeys = [];\n      // Bind hotkeys to the current element (and any children)\n      this.mousetrap = new Mousetrap.default(this.elementRef.nativeElement);\n    }\n    ngOnInit() {\n      for (const hotkey of this.hotkeys) {\n        const combo = Object.keys(hotkey)[0];\n        const hotkeyObj = new Hotkey(combo, hotkey[combo]);\n        const oldHotkey = this.hotkeysService.get(combo);\n        if (oldHotkey !== null) {\n          // We let the user overwrite callbacks temporarily if you specify it in HTML\n          this.oldHotkeys.push(oldHotkey);\n          this.hotkeysService.remove(oldHotkey);\n        }\n        this.hotkeysList.push(hotkeyObj);\n        this.mousetrap.bind(hotkeyObj.combo, hotkeyObj.callback);\n      }\n    }\n    ngOnDestroy() {\n      for (const hotkey of this.hotkeysList) {\n        this.mousetrap.unbind(hotkey.combo);\n      }\n      this.hotkeysService.add(this.oldHotkeys);\n    }\n    static {\n      this.ɵfac = function HotkeysDirective_Factory(t) {\n        return new (t || HotkeysDirective)(i0.ɵɵdirectiveInject(HotkeysService), i0.ɵɵdirectiveInject(i0.ElementRef));\n      };\n    }\n    static {\n      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n        type: HotkeysDirective,\n        selectors: [[\"\", \"hotkeys\", \"\"]],\n        inputs: {\n          hotkeys: \"hotkeys\"\n        },\n        features: [i0.ɵɵProvidersFeature([HotkeysService])]\n      });\n    }\n  }\n  return HotkeysDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HotkeysCheatsheetComponent = /*#__PURE__*/(() => {\n  class HotkeysCheatsheetComponent {\n    constructor(hotkeysService) {\n      this.hotkeysService = hotkeysService;\n      this.helpVisible$ = new BehaviorSubject(false);\n      this.title = 'Keyboard Shortcuts:';\n    }\n    ngOnInit() {\n      this.subscription = this.hotkeysService.cheatSheetToggle.subscribe(isOpen => {\n        if (isOpen !== false) {\n          this.hotkeys = this.hotkeysService.hotkeys.filter(hotkey => hotkey.description);\n        }\n        if (isOpen === false) {\n          this.helpVisible$.next(false);\n        } else {\n          this.toggleCheatSheet();\n        }\n      });\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n    toggleCheatSheet() {\n      this.helpVisible$.next(!this.helpVisible$.value);\n    }\n    static {\n      this.ɵfac = function HotkeysCheatsheetComponent_Factory(t) {\n        return new (t || HotkeysCheatsheetComponent)(i0.ɵɵdirectiveInject(HotkeysService));\n      };\n    }\n    static {\n      this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n        type: HotkeysCheatsheetComponent,\n        selectors: [[\"hotkeys-cheatsheet\"]],\n        inputs: {\n          title: \"title\"\n        },\n        decls: 10,\n        vars: 7,\n        consts: [[1, \"cfp-hotkeys-container\", \"fade\", 2, \"display\", \"none\", 3, \"ngClass\"], [1, \"cfp-hotkeys\"], [1, \"cfp-hotkeys-title\"], [4, \"ngFor\", \"ngForOf\"], [1, \"cfp-hotkeys-close\", 3, \"click\"], [1, \"cfp-hotkeys-keys\"], [\"class\", \"cfp-hotkeys-key\", 4, \"ngFor\", \"ngForOf\"], [1, \"cfp-hotkeys-text\"], [1, \"cfp-hotkeys-key\"]],\n        template: function HotkeysCheatsheetComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵelementStart(0, \"div\", 0);\n            i0.ɵɵpipe(1, \"async\");\n            i0.ɵɵelementStart(2, \"div\", 1)(3, \"h4\", 2);\n            i0.ɵɵtext(4);\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(5, \"table\")(6, \"tbody\");\n            i0.ɵɵtemplate(7, HotkeysCheatsheetComponent_tr_7_Template, 5, 2, \"tr\", 3);\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(8, \"div\", 4);\n            i0.ɵɵlistener(\"click\", function HotkeysCheatsheetComponent_Template_div_click_8_listener() {\n              return ctx.toggleCheatSheet();\n            });\n            i0.ɵɵtext(9, \"\\xD7\");\n            i0.ɵɵelementEnd()()();\n          }\n          if (rf & 2) {\n            i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(5, _c0, i0.ɵɵpipeBind1(1, 3, ctx.helpVisible$)));\n            i0.ɵɵadvance(4);\n            i0.ɵɵtextInterpolate(ctx.title);\n            i0.ɵɵadvance(3);\n            i0.ɵɵproperty(\"ngForOf\", ctx.hotkeys);\n          }\n        },\n        dependencies: [i2.NgClass, i2.NgForOf, i2.AsyncPipe],\n        styles: [\".cfp-hotkeys-container[_ngcontent-%COMP%]{display:table!important;position:fixed;width:100%;height:100%;top:0;left:0;color:#333;font-size:1em;background-color:#ffffffe6}.cfp-hotkeys-container.fade[_ngcontent-%COMP%]{z-index:-1024;visibility:hidden;opacity:0;transition:opacity .15s linear}.cfp-hotkeys-container.fade.in[_ngcontent-%COMP%]{z-index:10002;visibility:visible;opacity:1}.cfp-hotkeys-title[_ngcontent-%COMP%]{font-weight:700;text-align:center;font-size:1.2em}.cfp-hotkeys[_ngcontent-%COMP%]{width:100%;height:100%;display:table-cell;vertical-align:middle}.cfp-hotkeys[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]{margin:auto;color:#333}.cfp-content[_ngcontent-%COMP%]{display:table-cell;vertical-align:middle}.cfp-hotkeys-keys[_ngcontent-%COMP%]{padding:5px;text-align:right}.cfp-hotkeys-key[_ngcontent-%COMP%]{display:inline-block;color:#fff;background-color:#333;border:1px solid #333;border-radius:5px;text-align:center;margin-right:5px;box-shadow:inset 0 1px #666,0 1px #bbb;padding:5px 9px;font-size:1em}.cfp-hotkeys-text[_ngcontent-%COMP%]{padding-left:10px;font-size:1em}.cfp-hotkeys-close[_ngcontent-%COMP%]{position:fixed;top:20px;right:20px;font-size:2em;font-weight:700;padding:5px 10px;border:1px solid #ddd;border-radius:5px;min-height:45px;min-width:45px;text-align:center}.cfp-hotkeys-close[_ngcontent-%COMP%]:hover{background-color:#fff;cursor:pointer}@media all and (max-width: 500px){.cfp-hotkeys[_ngcontent-%COMP%]{font-size:.8em}}@media all and (min-width: 750px){.cfp-hotkeys[_ngcontent-%COMP%]{font-size:1.2em}}\"]\n      });\n    }\n  }\n  return HotkeysCheatsheetComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HotkeyModule = /*#__PURE__*/(() => {\n  class HotkeyModule {\n    // noinspection JSUnusedGlobalSymbols\n    static forRoot(options = {}) {\n      return {\n        ngModule: HotkeyModule,\n        providers: [HotkeysService, {\n          provide: HotkeyOptions,\n          useValue: options\n        }]\n      };\n    }\n    static {\n      this.ɵfac = function HotkeyModule_Factory(t) {\n        return new (t || HotkeyModule)();\n      };\n    }\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: HotkeyModule\n      });\n    }\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n        imports: [CommonModule]\n      });\n    }\n  }\n  return HotkeyModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of angular2-hotkeys\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Hotkey, HotkeyModule, HotkeyOptions, HotkeysCheatsheetComponent, HotkeysDirective, HotkeysService };\n"],"mappings":"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","names":["require_mousetrap","__commonJSMin","exports","module","window","document","undefined","_MAP","_KEYCODE_MAP","_SHIFT_MAP","_SPECIAL_ALIASES","_REVERSE_MAP","i","_addEvent","object","type","callback","_characterFromEvent","character","_modifiersMatch","modifiers1","modifiers2","_eventModifiers","modifiers","_preventDefault","_stopPropagation","_isModifier","key","_getReverseMap","_pickBestAction","action","_keysFromString","combination","_getKeyInfo","keys","_belongsTo","element","ancestor","Mousetrap","targetElement","self","_sequenceLevels","_resetTimer","_ignoreNextKeyup","_ignoreNextKeypress","_nextExpectedAction","_resetSequences","doNotReset","activeSequences","_getMatches","e","sequenceName","level","matches","deleteCombo","deleteSequence","_fireCallback","combo","sequence","callbacks","maxLevel","processedSequenceCallback","ignoreThisKeypress","_handleKeyEvent","_resetSequenceTimer","_bindSequence","_increaseSequence","nextAction","_callbackAndReset","isFinal","wrappedCallback","_bindSingle","info","combinations","initialEventTarget","documentMousetrap","method","Mousetrap","Hotkey","_Hotkey","combo","map","comboSplit","i","callback","allowIn","description","action","persistent","sequence","HotkeyOptions","InjectionToken","HotkeysService","options","Subject","event","element","_","hotkey","specificEvent","temp","key","shouldExecute","target","nodeName","allow","index","t","ɵɵinject","ɵɵdefineInjectable","HotkeyModule","options","HotkeysService","HotkeyOptions","t","ɵɵdefineNgModule","ɵɵdefineInjector","CommonModule"],"x_google_ignoreList":[0,1]}